---
title: 学习小结（1）
date: 2021-12-10 17:37:57
tags: java
categories: 笔记
---

<!--more-->

JAVA基础中toString\(\)的讲解

1.要理解toString\(\)方法，首先要知道，在JDk中提供一个Object类，它是所有类的父类，即每个类都直接或间接的继承自该类。  
2.这个toString\(\)方法解析开来，其实就是getClass\(\).getName\(\)+"\@"+Integer.toHexString\(hashCode\(\)\);第一眼看上去感觉很复杂，我们对照刚刚打印的信息来看：  
getClass\(\).getName\(\)+"\@"+Integer.toHexString\(hashCode\(\)\)  
pers.day02.Animal\@73035e27  
1）getClass\(\).getName\(\)代表返回对象所属类的包名.类名，即pers.day02.Anima。  
2）\@对应\@;  
3）Integer.toHexString\(hashCode\(\)\)代表将对象的哈希值用16进制表示，其中hashCode\(\)代表返回该对象的哈希值。

3.然而，在实际开发中，通常希望toString\(\)方法返回的不只是基本信息，所以Object的toString\(\)方法通常会被重写，如下，我们只需在Animal类中重写toString\(\)即可。  
 

JAVA中equals的用法：  
Object类中的equals方法用于检测一个对象是否等于另一个对象。在Object类中，这个方法判断两个对象是否具有相同的引用，如果两个对象具有相同的引用，它们一定是相等的。从这点上看，将其作为默认操作也是合乎情理的。然而，对于多数类类说，这种判断并没有什么意义，例如，采用这种方式比较两个PrintStream是否相等就完全没有意义。然而，经常需要检测两个对象状态的相等性，如果两个对象的状态相等，就认为这两个对象是相等的。所以一般在自定义类中都要重写equals比较。

下面给出编写一个完美equals\(\)方法的建议：

1）显式参数命名为otherObject，稍后需要将转换成一个叫other的变量

2）检测this与otherObject是否引用同一个对象：

if\(this==otherObject\) return true;

这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小的多。

3）检测otherObject是否为null，如果为null，返回false。这项检测是很必要的。

if\(otherObject==null\) return false;

4）比较this和otherObject是否属于同一个类，如果equals的语义在每个子类中有所改变，就使用getClass\(\)检测，它将自己作为目标类

if\(getClass\(\)\!=otherObject.getClass\(\)\) return false;

如果所有的子类都拥有同一的语义，就使用instanceof检测

if\(\!\(otherObject instanceof ClassName\)\) return false;

5）将otherObject转换为相应类型的变量：

ClassName other=\(ClassName\)otherObject;

6）现在开始对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。如果所有域都匹配，就返回true，否则返回false；

return field1==other.field1\&\&field2.equals\(other.field2\)

如果在子类中重新定义equals，就要在其中包含调用super.equals\(other\)。如果检测失败，就不可能相等。如果超类中的域相等，就比较子类中的实例域。

对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的元素是否相等

一段时间学习的小结:  
1.通过extends关键字，可以将父类中的非私有成员（成员变量和成员方法）继承给子类；

2.父类中有多个构造方法时，如果要调用特定的构造方法，则可在子类的构造方法中通过super（）语句调用。

3.java程序在执行子类的构造方之前，如果没有用super（）语句来调用父类中特定的构造方法，则会调用父类中空参的构造方法，  
其目的是为了帮助继承自父类的成员做初始化操作。

4.在构造方法内调用同一类内其他构造方法时使用this（）语句；从子类的构造方法调用父类的构造方法则用super（）语句

5.this（）除了可以调用同一类的构造方法之外，如果成员变量与局部变量的名称相同时，也可以用this.变量名来调用同一类中的成员变量。

6.this\(\)与super\(\)的相似之处：（1）当构造方法有重载时，两者都会根据所给参数的个数和类型，正确地选择执行相对应的构造方法。

（2）两者必须编写在构造方法的第一行，也是因为这个原因，不能同时用this（）和super（）无法同时存在。

7.除了可以利用super（）来调用父类的构造方法外，还利用“super.成员名”的形式来调用父类中的成员变量或成员方法。

8.把成员变量声明成protected最大的好处就是兼顾成员的安全性与便利性，因为它只能提供父类，子类及同一个包中的类来访问，而其他类无法获取。

9.重载是指在同一个类中，具有相同的方法名，但是参数列表不同的多个方法。java系统可以根据参数的个数和类型，调用相应的方法。

10.覆盖是在子类当中，定义名称，参数个数和类型与父类相同的的方法，用以覆盖父类中方法的功能。

11.super和this关键字不能在有static环境中使用，包括静态初始化器和静态方法。

覆盖：  
  覆盖和重载相似，它们均是多态的技巧之一。  
覆盖：是指在子类中定义名称，参数个数与类型均与父类中完全相同的方法，用以重写父类中同名方法的功能。  
重载：是指在同一类下定义多个名称相同旦参数个数或类型不同的方法。  
子类中不能覆盖父类中声明为fianl或static。  
子类继承父类中所有可能被访问的成员方法时，如果子类的方法头与父类的方法头中的方法名完全相同，则不能继承，此时子类的方法是覆盖父类的方法。

在子类中覆盖父类的方法时，可以扩大父类中的方法权限，但不可以缩小父类的方法权限。

  
fianl：  
  》凡是被声明为final的量均为常量，而常量不能在程序的任何地方再做修改。  
  》如果一个类被final修饰符所修饰，则说明这个类不能再被其他类所继承，即该类不可能有子类，这种类统称为最终类；  
  》fianl成员变量和fianl局部变量都是只读量，它们能且只能被赋值一次，而不能被赋值多次。  
  》定义一个成员变量时，若只用final修饰而不用static修饰，则必须且只能赋值一次，不能默认。赋值方式有两种：  
     一种是在定义变量时赋值，另一种是在某一个构造方法中赋值。

Object类：

public boolean equals\(Object obj\)    判断两个对象变量所指向的是否为同一个对象。  
public Sting toString\(\)                       将调用toString（）方法的对象转换成字符串。

“==”和“equals”:  
比较字符串时：运算符用于比较两个变量本身的值，即两个对象的首地址值，而equals（）方法则是比较字符串中所包含的内容是否相同。  
比较非字符串时：两个都是用来比较两个类类型的变量是否指向。

toString（）方法：  
   》toString（）方法的功能是将调用的该方法的对象的内容转换成字符串，并返回其内容，但返回的是一些没有意义看不懂的字符串；

getClass（）方法：  
  》该方法的功能是返回运行时的对象所属的类；  
  》getClass（）方法返回值是Class类型，必须先声明一个obj所属的类；

对象运算符 instanceof  
 》利用对象运算符来测试一个指定对象是否是指定类或它的子类的实例，若是则返回true，不是返回false

  
类的继承：  
  》类的继承是使用已有类为基础派生出来的类，类的继承是程序代码再利用。  
  》被继承的称为父类，得到继承的称为子类。一个父类可以有多个子类，但由于java语言不支持多重继承，所以一个类只能有一个直接父类。  
  》子类继承父类可访问的成员变量和成员方法，同时可以修改父类的成员变量，或重写父类的方法，也可以添加新成员和新方法。  
  》在java语言中有一个名为java.lang.Object的特殊类，所有类都是直接或间接继承该类得到的。  
  》通过关键字extends来继承：  
class SubClass extends SupperClass  
         \{   
         .  
         .  
         .  
         \}

 子类的每个对象也是其父类的对象，父类的对象不一定是子类的对象。

  
抽象类：  
\--》根据抽象类的格式来创建和修改新的类，但不能直接由抽象类创建对象，只能通过抽象类派生出来的子类，再由其子类来创建对象。  
\--》抽象类是不能用new运算符来创建实例对象，可以作为父类被它的所有子类所共享。

  
abstract class 类名\{<!-- -->  
       声明成员变量；  
       返回值的数据类型  方法名\(参数表\)\{<!-- -->

           
       \}

       abstract 返回值的数据类型   方法名\(参数表\);  
\}

在抽象类中的方法可以分为两种：  
》一种是带有方法体的一般方法  
》另一种是没有方法体的“抽象方法”，以abstract关键字开头的方法，此方法只声明返回值的数据类型，方法名称与所需的参数，但是没有方法体。

  
》抽象方法指定了必须做的工作。而不去指定如何去做这件工作。只需要声明，不需要实现。  
》抽象方法声明中修饰符static和abstrac不能同时使用。  
》由于抽象类是需要被继承的，所有不能用final来修饰，abstract和final不能合用。  
》abstract不能与private，static，final或native并列修饰同一个方法。  
》抽象类可以有构造方法，且构造方法可以被子类的构造方法调用，但构造方法不能被声明为抽象的。