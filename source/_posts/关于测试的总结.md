---
title: 关于测试的总结
date: 2021-11-23 12:24:17
tags: java 开发语言 后端
categories: 笔记
---

<!--more-->

### final关键字  
1.修饰变量    
凡是对成员变量或者局部变量\(在方法中的或者代码块中的变量称为本地变量\)声明为final的都叫作final变量。final变量经常和static关键字一起使用，作为常量。  
final修饰基本数据类型的变量时，必须赋予初始值且不能被改变，修饰引用变量时，该引用变量不能再指向其他对象  
2.修饰方法  
final也可以声明方法。方法前面加上final关键字，代表这个方法不可以被子类的方法重写。如果你认为一个方法的功能已经足够完整了，子类中不需要改变的话，你可以声明此方法为final。final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。  
3.修饰类  
使用final来修饰的类叫作final类。final类通常功能是完整的，它们不能被继承。Java中有许多类是final的，譬如String, Interger以及其他包装类。

### 深入分析final关键字  
1.被final修饰的对象内容是可变的  
虽然对象被final修饰对象不可被继承，但其内容依然可以被改变

### 关于void  
Java语言是强类型（Strong typed）的，从方法申明的语法可以看出方法的定义必须有返回值，需要确定方法返回值的类型；当方法定义时用void修饰时，表示没有返回值，那么由此可见void的应该算是一种数据类型。而Java中只有两种数据类型，即基本数据类型和引用数据类型。

### 关于static  
static最常用的功能就是修饰类的属性和方法，让他们成为类的成员属性和方法，我们通常将用static修饰的成员称为类成员或者静态成员，

### 数据类型转换  
自动类型转换\(也叫隐式类型转换\) ，其实就是小范围的数据类型向大范围的数据类型转换，例如int类型转long  
\*强制类型转换\(也叫显式类型转换\) int b = \(int\)\(i + j\)  
\*强制类型转换在某种情况下会丢失精度     
\*表达式的数据类型自动提升  
a、所有的byte型、short型和char的值将被提升到int型  
b、如果一个操作数是long型，计算结果就是long型  
c、如果一个操作数是float型，计算结果就是float型  
d、如果一个操作数是double型，计算结果就是double型  
e、如果一个操作数是String型，计算结果就是String

### string类型不能被继承  
什么样的类不能被继承？  
　一，在Java中，只要是被定义为final的类，也可以说是被final修饰的类，就是不能被继承的。  
　二，final是java中的一个关键字，可以用来修饰变量、方法和类。用关键词final修饰的域成为最终域。用关键词final修饰的变量一旦赋值，就不能改变，也称为修饰的标识为常量。如果一个类的域被关键字final所修饰，它的取值在程序的整个执行过程中将不会改变。  
　三，假如说整个类都是final，就表明自己不希望从这个类继承，或者不答应其他任何人采取这种操作。换言之，出于这样或那样的原因，我们的类肯定不需要进行任何改变；或者出于安全方面的理由，我们不希望进行子类化（子类处理）。  
  
\&和\&\&的联系和区别？  
都是逻辑运算符，当运算符左右两边的表达式都为 true，才返回 true。  
双与具有短路性，如果第一个表达式为 false，则直接返回 false。

### 数组有没有length\(\)这个方法\?String有没有length\(\)这个方法\?  
数组没有方法,更没有length方法，查看数组长度用的是x.length，此时的length是数组的属性，String有length\(\)方法,查看当前字符串的字符个数。

### 如何高效计算2\*8  
利用位运算  
位运算是对二进制数进行运算，左移一位相当于二进制数往左移了一位。  
2=10\(二进制\) ，左移三位后变为 16=1000（二进制）。  
所以2×8用2\<\<3运算更有效率。  
在底层代码中，左移和右移是效率极其高的运算方式。

### 反思:  
      对于部分基础知识的记忆仍需加强，要加强理解程序设计的思路和写法。我觉得只有看和记是不够的，对于我而言，边看边记，还要边刷题，才能够加深记忆。对于测试的结果，我有深刻的认知，我想自己是否足够努力了，我的时间是否有效率的利用了，有哪些地方需要加强，这仍是我值得去思考和安排的地方。我想自己可以有提高，这需要更加的努力。